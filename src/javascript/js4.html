<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="common.css">
    <title>js4</title>
    <script>
        var add = (function () {
            var counter = 0;
            return function () {return counter += 1;}
        })();
        function myFunction(){
            debugger;
            document.getElementById("demo").innerHTML = add();
        }

        function createEle() {
            var para = document.createElement("p");
            para.id="pnew"
            var node = document.createTextNode("这是一个新的段落。");
            para.appendChild(node);

            var element = document.getElementById("div1");
            element.appendChild(para);
        }

        function removeEle() {
            var parent = document.getElementById("div1");
            var child = document.getElementById("pnew");
            parent.removeChild(child);
        }

    </script>
</head>
<body>
    <div class="container">

        <div class="table">

            <b>JavaScript 函数参数</b>
            <p>ES5 中如果函数在调用时未提供隐式参数，参数会默认设置为： undefined</p>
            <pre>//设置默认值
//ES5
function myFunction(x, y) {
    if (y === undefined) {
          y = 0;
    }
}
//如果y已经定义 ， y || 返回 y,
//因为 y 是 true, 否则返回 0, 因为 undefined 为 false。
function myFunction(x, y) {
    y = y || 0;
                }</pre>
<b>ES6默认值</b>
<pre>//ES6
function myFunction(x, y = 10) {
    // y is 10 if not passed or undefined
    return x + y;
}
myFunction(0, 2) // 输出 2
myFunction(5); // 输出 15, y 参数的默认值</pre>

            <b>arguments 对象</b>
            <pre>x = sumAll(1, 123, 500, 115, 44, 88);
function sumAll() {
    var i, sum = 0;
    for (i = 0; i < arguments.length; i++) {
        sum += arguments[i];
    }
    return sum; }</pre>


        </div>

        <div class="table">
            <b>作为函数方法调用函数 call() 和 apply() </b>
            <pre>function myFunction(a, b) {
    return a * b;
}
myObject = myFunction.call(myObject, 10, 2); // 返回 20
//apply
function myFunction(a, b) {
    return a * b;
}
myArray = [10, 2];
myObject = myFunction.apply(myObject, myArray); // 返回 20</pre>
            <p>两个方法都使用了对象本身作为第一个参数。 两者的区别在于第二个参数： apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。</p>

            <b>局部变量计数</b><br/>
            <button type="button" onclick="myFunction()">计数!</button>
            <p id="demo">0</p>

            <br/>
            <b>appendChild()、insertBefore()、removeChild()/replaceChild()</b>
            <pre>var para = document.createElement("p");
var node = document.createTextNode("这是一个新的段落。");
para.appendChild(node);
var element = document.getElementById("div1");
element.appendChild(para);</pre>
            <div id="div1" ></div>
            <button onclick="createEle()">创建新的元素节点</button>
            <button onclick="removeEle()">移除元素节点</button>

        </div>

        <div class="table">

            <b>HTMLCollection NodeList对象</b>
            <pre>//collection 可以像数组一样，使用索引来获取元素。
var myCollection = document.getElementsByTagName("p");

//NodeList
var myNodeList = document.querySelectorAll("p");
            </pre>
            <p>HTMLCollection 是 HTML 元素的集合。<br/>
                NodeList 是一个文档节点的集合。<br/>
                HTMLCollection 元素可以通过 name，id 或索引来获取。<br/>
                document.getElementsByTagName() 返回的是一个动态的Node List可以获取js动态增加的节点.<br/>
                而queryselectorAll()返回的是一个静态的Node List，不可以获取js动态增加的节点。<br/>
                在获取了元素的集合后,再插入新的元素,.getElementsByTagName()的元素集合会添加新插入的元素，而queryselectorAll()不会</p>

            <b>prototype（原型对象）</b>
            <pre>//使用 prototype 属性就可以给对象的构造函数添加新的属性
function Person(first, last, age, eyecolor) {
  this.firstName = first;
  this.lastName = last;
  this.age = age;
  this.eyeColor = eyecolor;
}
Person.prototype.nationality = "English";
//也可以使用 prototype 属性就可以给对象的构造函数添加新的方法
Person.prototype.name = function() {
  return this.firstName + " " + this.lastName;
}；</pre>

        </div>

    </div>

</body>
</html>